# 第一章 简述
	当用java命令运行某个类的main函数启动程序时，首先要通过类加载器把 主类 加载到JVM

## Oracle的Java Virtual Machine 和 VMware虚拟机
	JVM是一个虚拟构造的计算机,是在实际计算机仿真模拟各种计算机功能实现的,他有自己完善的硬件架构(如处理器,堆栈,寄存器等),还具有相应的指令系统.使用JVM是为了支持与操作系统无关,在任何系统都可运行的程序.
	VMware是一个用来兼容的程序,用来在计算机上在虚拟出多台机器的

## JVM背景
	Java HotSpot Virtual Machine 正式发布,成为java的默认虚拟机HotSpot 是较新的虚拟机,使用JIT(just in time)编译器,可以大大提高Java运行的性能
	在jdk 1.7u4中,正式启用了新的垃圾回收器G1
	2018年,发布了振奋人心的jdk11,LTS版本的jdk,革命性的ZGC(新式垃圾回收器)

## 其他虚拟机
	Sun classic VM --> Sun Inc.早期虚拟机
	JRockit --> BEA Inc.
	J9 -->IBM
	Graal VM --> "Run Programs Faster Anywhere"

##  java.exe到java类加载
![1640967583528](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1640967583528.png)

# 第二章 字节码
## 1).加载
	在硬盘上查找并通过IO读入字节流文件，使用到类时才会加载
	例如调用类的main() new 对象,在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种访问口
## 2).验证 
	校验字节码文件的正确性
## 3).准备
	给类的静态变量分配内存，并赋予默认值
## 4).解析
	将符号引用替换为直接引用，该阶段会把一些静态方法(main()),替换为指向数据所存内存
	的指针，（符号引用——>直接引用）,这就是静态链接，动态链接是在程序运行期间完成的（符号引用——>直接引用）
## 5).初始化
	对类的静态变量初始化为指定的值，执行静态代码块

## 类加载

![1641093402982](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641093402982.png)

## JVM调优步骤

![1641093981756](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641093981756.png)

## class文件的编译器翻译并执行

![1641094882362](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641094882362.png)


## 虚拟机指令的运用

	invokevirtual
	调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）,支持多态。这也是Java语言中最常见的方法分派方式
	虚方法：能够动态绑定，能够被重写
	
	invokeinterface
	调用接口方法，它在运行时搜索由特定对象所实现的这个接口方法，并找出合适的方法进行调用。
	
	invokespecial
	调用一些需要特殊处理的实例方法，包括实例初始值方法（构造器）、私有方法、父类方法，这些方法都是动态绑定的，不会在调用的时候进行动态派发
	
	invokestatic
	调用类方法（Invoke a class (static) method ），这是静态绑定的
	
	invokedynamic
	调用动态绑定的方法，这个是jdk 1.7后新加入的指令，用于在运行时动态解析出限定符所引用的方法，并执行该方法   

## 面试题

###  为什么不把基本类型放堆中
	首先是堆栈的特点不同，堆的空间虽然大，但是栈的运行速度更快，因为引用数据类型（数组，集合）占用的内存空间比较大，所以放在堆里面，故堆负责存储，栈负责运行。

###  Java中的参数是传值呢，还是传引用
	值传递

###  java中有没有指针的概念
	Java中的对象类型本质上应该叫做 对象指针类型。那么传统的对象类型呢，在Java中早已不见了踪影！既然没有了传统的对象类型，那么对象指针变量前面的（*，&）也就可以不要了。对象指针变量也就可以简称为对象变量了。没有了指针的加减运算，也就没有了*、->等运算符，这是对指针的简单化。
	在C中，对地址值的赋值是通过偏移指针，而Java中赋值是通过获取索引的方式

# 第三章 类的加载
	装载Loading、链接Linking、初始化Initialzation

## Java类加载机制
	类的加载分为七个阶段：加载、（验证、准备、解析）、初始化、使用、卸载
	其中验证、准备、解析归为链接阶段
	验证：字节码验证通过对字节码流的分析，判断字节码是否可以被正确的执行
	准备（重）：为类的静态变量分配内存，并将它初始化为默认值（char \u0000),这里不包含基本数据类型的字段用static final修饰的情况，因为final该变量就相当于常量了，在编译的时候就会分配了，故在准备阶段会显式赋值。
	解析：将类、接口、字段和方法的符号引用转为直接引用（在内存中的指针或者偏移量），但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后在执行。

## 面试题
### 类只会加载一次吗
	java中有四种类加载器，程序运行需要的类都会由他们加载到内存中。这四种种类加载器分别是BootStrap ClassLoader、Extension ClassLoader、Application ClassLoader、自定义ClassLoader，一个类在JVM中可以加载很多次，但只能被同一个类加载器加载一次，每一个类，都拥有一个命名空间，比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，而flink的两个任务不会共用相同的类

### 有谁需要被类加载器加载
	基本数据类型有虚拟机预先定义
	引用数据类型则需要进行类的加载

### 加载阶段都做了什么
	把物理磁盘中存在的字节码文件加载到内存中，生成了Class实例，加载的类在JVM中创建了相应的类结构，类结构会存储在方法区(元空间)

### 永久代VS元空间
	方法区：jdk1.8之前：永久代、jdk1.8之后：元空间
	元空间不在虚拟机中，使用的是本地存储；永久代使用的是JVM内存
	元空间相比永久代的优势:
		元空间可以通过-XX：MetaspaceSize和-XX：MaxMetaspaceSize参数来指定元空间的大小，假如字符串常量池存放在永久代中，容易出现性能问题和内存溢出，类和方法的信息大小难以确定，给永久代的代销指定带来困难，会为GC带来不必要的复杂性，而元空间方便HotSpot与其他JVM如Jrockit的集成

### 子类加载前是否先加载父类
	在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的初始化（clinit）总是在子类（clinit）之前被调用。也就是说，父类的static块优先级高于子类
	口诀：
		由父及子，静态先行

### 如何判断是在初始化阶段还是在链接阶段赋值？
	使用static final 修饰的成员变量，称为：全局常量
	在链接（Linking）阶段，赋的值是常量
	在初始化阶段（clinit）中，涉及到方法或构造器的使用

### 哪些情况会触发类的加载？
	类的加载 = 装载 + 链接（1，2，3） + 初始化

## 主动使用类VS被动使用
### 主动使用
	主动使用是指在一个类或接口在初次使用前，必须进行初始化。
	主动使用只有下列几种情况：
	当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化
	当调用了类的静态方法时，即当使用了字节码invokestatic指令
	当使用类、接口的静态字段时，比如使用getstatic或者putstatic指令A
	当使用java.lang.reflect
	当初始化子类的时候，如果发现其父类还没有进行过初始化，需要先对父类进行初始化
	如果一个接口定义了default方法，那么直接实现或者简介实现该接口的初始化该接口的类的初始化该接口要在其之前被初始化

### 被动使用
	当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。
	通过数组定义类引用，不会触发此类的初始化
	引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了
	调用ClassLoader类的loadClass（）方法加载一个类，并不是对类的主动使用，不会导致类的初始化
	被动的使用，意味着不需要执行初始化环节，意味着没有（clinit）的调用

## 方法区的垃圾回收
	方法区的垃圾收集主要回收两部分：常量池中废弃的常量和不再使用的类型

## 类的加载器
	ClassLoader:在整个装载阶段，只能影响到类的加载
## 显示加载VS隐式加载
	显示加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象
	隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类import java.util.*的对象，此时额外引用的类将通过JVM自动加载到内存中。

## 类加载器分类

![1641355635172](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641355635172.png)

类加载器分为两类：C语言编写的启动类加载器 和 Java 编写的ClassLoader加载器以及继承至类加载器的用户自定义类，出于安全考虑，BootStrap启动类加载器只加载包名为java，javax，sun开头的类




## 对ClassLoader的源码分析

## 为什么要自定义加载类
	隔离加载类 在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内部某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。在比如：Tomcat这类Web应用服务器，内部定义了好几种加载器，用于隔离同一个Web应用服务器上的不同应用程序。（类的仲裁-->类的冲突）
	修改类的加载方式 类的加载模型并非强制，除了启动类加载器外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需动态加载
	扩展加载源 比如数据库、网络、甚至是电视机机顶盒进行加载
	防止源码泄露 Java代码很容易被编译和泄露，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。
# 第四章 双亲委派机制
![1641360418285](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641360418285.png)

	如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；如果父类加载器还存在其父类加载器，则进一步委托，依次递归，请求最终将到达顶层的启动类加载器；
	如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派机制。

## 双亲委派机制特点
	优点：避免类的重复加载，确保一个类的全局唯一性。Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系，可以避免类的重复加载。
		当父类已经加载了一次该类时，就没有必要让自定义的ClassLoader在加载一次
		保护程序安全，防止核心API被破坏
	缺点：顶层ClassLoader无法访问底层的CLassLoader所加载的类
		启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，访问一些系统类没有问题，但是系统类访问应用类就会出现问题。
		比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还需要绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现在该工厂方法无法创建由应用类加载器加载的应用实例。（JDBC）

## 如何自定义加载类


## TomCat的破坏双亲委派机制的自定义类

![1641365920148](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641365920148.png)

加载顺序

![1641366122978](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641366122978.png)

## 面试题
### Tomcat使用双亲委派机制可以吗
	如果使用默认的，那么是无法同时加载两个相同的类库的不同版本，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份

### 怎么实现jsp文件的热替换
	jsp文件就是class文件，如果修改了，但类名还是一样，类加载器会直接取方法区中已经缓存的的，修改后的jsp是不会重新加载的。那么该怎么办呢？我们可以直接卸载掉这个jsp文件的类加载器，重新创建类加载器，重新加载jsp文件

### 如果TomCat的Common ClassLoader想要加载WebApp ClassLoader 中的类，该怎么办？
	可以使用线程上下文类加载器实现，让父类加载器请求子类加载器去完成类加载的动作。

### 为什么java文件放在idea中的src文件夹下会优先jar包下的class
	因为idea中的src文件夹中的java文件以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在WEB-INF/classes中，而外部引用的jar包，相当于放在WEB-INF/lib中

# 运行时内存栈

![1641375206051](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641375206051.png)

## 为什么需要程序计数器
	PC寄存器用来存储指向下一条指令的地址，也是即将要执行的指令代码。执行引擎的字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的指令。

## 为什么执行native方法，是undefined
	native本地方法是通过C实现，没有编译成字节码指令，所以自然是未定义

## PC寄存器存储字节码指令地址有什么用
	因为CPU需要不停的切换各个线程，这时候切换回来以后，就需要知道接着从哪开始继续执行

## PC寄存器为什么会被设定为线程私有
	为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法是为每一个线程都分配一个PC寄存器

## 栈和堆的区别是什么
	栈只保留堆中当前对象的引用地址，栈的空间小，运算速度快，堆的空间大，运行速度慢
	栈管运行，堆管存储

## 栈中存在GC吗
	栈中不存在垃圾回收，栈会溢出

## StackOverFlow （栈溢出）对比 OutOfMemoryError（内存溢出）
	如果线程请求分配的单个栈容量超过Java虚拟机允许的最大容量，java虚拟机将会抛出一个StackOverFlow
	如果在创建新的线程时，没有足够的内存去创建对应的多个虚拟机栈，那Java虚拟机将会抛出OutOfMemoryError（局部数组过大，递归调用层次太多，运行时会执行压栈操作）

## 如何设置栈内存大小
	默认为512~1024kb
	-Xss （size） 当设置栈控制值过大，会导致系统可以创建线程的数量减少，通常一个进程中有3000~5000个线程
	jdk5.0之前默认大小：256K
	jdk5.0之后默认大小：1024K
	-Xss0 Windows下赋值为0,但实际赋值为1024k
	配置步骤：Run-Debug Configurations-Application-ClassName-Configuration-VMoptions

## 栈的单位：栈针
	每个线程都有自己的栈，栈中的数据都是以栈针的格式存在

## 方法和栈针的关系
	一个桟帧对应着一个方法，栈的特性决定了在栈底的桟帧1，所对应的方法一还没被执行完，就执行了方法二，也就是对应的桟帧2，在一条活动线程中，一个时间点上，只会有一个活动的栈帧，这个桟帧被称为当前桟帧。

![1641435657924](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641435657924.png)

## 栈的主要存储内容
	每个桟帧中存储着：局部变量表
				   操作数栈
				   动态链接
				   方法返回地址
## 局部变量VS静态变量
	局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量，则必须人为的初始化，否则无法使用。

## 哪些内容可作为GC ROOTS
	局部变量表，只要被局部变量表中直接或间接引用的对象都不会被回收
## 什么是局部变量表
	存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型，对象引用，returnAddress），long和double会占据两个slot（槽位）
## 什么是操作数栈
	保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间

## 什么是栈顶缓存技术
	将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率

## 动态链接

![1641564985598](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641564985598.png)


## 方法返回地址
	调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址
	正常完成出口和异常完成出口的区别是：通过异常完成出口退出的不会给它的上层调用者产生任何的返回值

## 栈溢出的情况
	栈溢出:StackOverflowError;
	举个简单的例子:在main方法中调用main方法,就会不断压栈执行,直到栈溢出;
	栈的大小可以是固定大小的,也可以是动态变化（动态扩展）的。
	如果是固定的,可以通过-Xss设置栈的大小;
	如果是动态变化的,当栈大小到达了整个内存空间不足了,就是抛出OutOFMemory异常

## 调整栈大小,就能保证不出现溢出吗?
	不能。因为调整栈大小,只会减少出现溢出的可能,栈大小不是可以无限扩大的,所以不能保证
## 分配的栈内存越大越好吗?
	不是,因为增加栈大小，会造成每个线程的栈都变的很大,使得一定的栈空间下,能创建的线程数量会变小
## 垃圾回收是否会涉及到虚拟机栈
	不会;垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能;
	虚拟机栈和本地方法栈,都是只涉及压栈和出栈,可能存在栈溢出,不存在垃圾回收。

## 方法中定义的局部变量是否线程安全
	假如线程私有，不会被其他方法调用，线程是安全的
	线程是公开的，并且有返回值，会有可能被其他方法调用，线程是不安全的

## 什么是本地方法
	一个Native Method就是一个Java调用非Java代码的接口。

## 为什么要用NativeMethod
	与Java环境外交互:Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。
	Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交流
	当某个线程调用本地方法时，他就不会再受虚拟机领域的限制，它和虚拟机拥有同样的权限
		本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
		他甚至可以直接使用本地处理器的寄存器
		直接从本地内存的堆中分配任意数量的内存
## 本地方法现状
	目前使用的越来越少了，除非是与硬件有关的应用

# 运行时内存堆
	一个实例只存在一个堆内存，堆内存的大小是可以调节的，堆的物理内存空间可以不连续，但在逻辑上他应该被视为连续的。
	在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除

## 对象默认都分配在堆上吗
	所有的对象实例以及数组都应当在运行时分配在堆上，也可以自定义将一些在堆上的对象放在栈上，增加安全性。  

## 所有的线程都共享堆吗
	所有的线程都共享堆Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer、TLAB（快速分配策略））

## 堆的内部结构

![1641614561734](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641614561734.png)
	新生代+老年代+元空间
	新生代是指对象的创建和消亡持续时间都很低
	老年代生命周期很长，有时与GC生命周期相同
	几乎所有的Java对象都得先被Eden区被new出来，之后在判断是在老年代还是新生代存活

## 如何设置堆空间大小
	-Xms用于表示堆空间的起始内存、
	-Xmx用于表示堆空间的最大内存
	当堆区中的内存大小超过时，将会抛出OutOfMemoryError：heap异常
	通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
	如果物理内存大于等于1G，那么heap的最大值为物理内存的四分之一，最小值为物理内存的六十四分之一

## 如何设置新生代老年代比例
	默认值是 -XX：NewRation =2 ，新生代占1，老年代占2，新生代占整个堆的三分之一

## 什么叫分配担保策略
	MinorGC：针对于新生代的GC，只要老年代的连续空间大于新生代对象总大小就会进行MinoGC，负责就进行FullGC
	如果对象在Eden出生并经过第一次MinorGC 后仍然存活，并且能被Survivor容纳，将被转移到S空间中，并将对象年龄设置为1。对象在s区中每熬过一次MinorGC，年龄就增加一岁，当它的年龄增加到15岁时（每个JVM年龄都不同），就会被晋升到老年代

## 什么时候对象会进入老年代
	针对幸存者s0，s1：复制之后有交换，谁空谁是to
	频繁在新生区收集
	很少在养老区收集
	几乎不在永久区、元空间收集

## 内存分配原则
	优先分配到Eden区
	大对象直接分配到老年代，但尽量避免程序中出现大对象
	长期存活的对象分配到老年代
	如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或	等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。
	空间分配担保  -XX：HandlePromotionFailure  true/false

## 什么是空间分配担保
	在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间 是否大于新生代所有对象的总空间
	如果大于，则是安全的，反之，则会继续检查 老年代最大可用连续空间 大于 新生代对象总大小 或 历次晋升的平均大小 则会Minor GC 如果小于  或  空间分配担保（HandlePromotionFailure）为false则改为进行一次FUll GC
	-XX：HandlePromotionFailure	

##  解释MinorGC、MajorGC、FullGC
	针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型:·一种是部分收集（Partial GC，只回收新生代、老年代、其中之一) 一种是整堆收集（Full GC，全部回收)
	注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回仅还是整堆回收
​    混合收集（Mixed GC):收集整个新生代以及部分老年代的垃圾收集
​	整堆收集（Full GC):收集整个java堆和方法区的垃圾收集

## 什么时候会触发垃圾回收
	年轻代空间不足时（这里指Eden区），会触发Minor GC，
	S满不会触发GC
	老年代触发时，经常会伴随至少一次的Minor GC，也就是说老年代空间不足时，会先触发Minor GC。如果之后空间还不足，则触发Major GC
	Major GC比Minor GC慢10倍以上，如果Major GC后，内存还不足，就报OOM了
	Full GC触发时，Minor GC和Major GC已经触发完，空间依然不足。通过Minor GC后进入老年代的平均大小大于老年代的可用内存

## OOM如何解决
	要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出Memory Overflow）
	如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码位置。
	如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-xms），与机器物理内存对比看是否还可以调大，从代码上检查是存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

## 什么是TLAB
	从内存模型而不是垃圾收集的角度，对Eden区域进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden区

![1641641948735](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641641948735.png)


	尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
	在程序中，开发人员可以通过选项“-XX:+/ -UseTLAB”设置是否开启TLAB空间。
	默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选:“-xX:TLABwasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的子性，从而直接在Eden空间中分配内存。

## 什么是方法区
	方法区（Method Area）与]ava堆一样，是各个线程共享的内存区域。

## 什么时候会出现元空间溢出
	加载大量的第三方Jar包：TomCat部署的工程过多（30~50）；大量动态的生成反射类
	解决方法：关闭JVM就会释放这个区域的内存

## 方法区中常用的参数
	jdk7及以前:
	通过-XX :PermSize来设置永久代初始分配空间。默认值是20.75M
		-XX:MaxPermSize来设定永久代最大可分配空间。64位机器模式是82M
		当JVM加载的类信息容量超过了这个值，会报异常OutOfMemoryError: PermGen space 
	jdk8及以后:
	元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定,替代上述原有两个参数
	默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，IXX:MaxMetaspaceSize 的值;-1，即没有限制。
	与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据E发生溢出，虚拟机一样会抛出异常outOfMemoryError: Metaspace
	-XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。
	如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可
	以观察到Full GC多次调用。为了避免频繁地GC，建议将-XX:MetaspaceSize设置为一个相对较高的值。

# 对象内存布局

![1641965842768](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641965842768.png)

## 你有几种方式创建对象
	最常见的方式
	new
		变形1:Xxx的静态方法
		变形2:XxxBuilder/XxxFactory的静态方法
	Constructor的newIlnstance(Xx):反射的方式，可以调用空参、带参的构造器，权限没有要求，实用性更广
	使用clone():不调用任何构造器，当前类需要实现Cloneable接口，实现clone()，默认浅拷贝
	使用反序列化:从文件中、数据库中、网络中获取一个对象的二进制流，反序列化为内存中的对象
	第三方库Objenesis，利用了asm字节码技术，动态生成Constructor对象团

## 创建对象的步骤
### 从字节码角度看待对象创建过程
	当new对象时，如果找不到Class对象，则进行类加载。加载成功后，则在堆中分配内存，从Object开始到本类路径上的所有属性值都要分配内存，将指向实例变量对象的引用变量压入虚拟机栈顶。
	在new完对象时，需要进行DUP：在栈顶复制该引用变量，这时的栈顶有两个指向堆内实例对象的变量，两个引用变量的目的不同，其中压入底部的引用用于赋值，另一个栈顶的引用变量作为句柄调用相关方法。

## 从执行步骤角度分析
	1.判断对象对应的类是否加载、链接、初始化
	虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。（即判断类元信息是否存在）
	如果没有类的符号引用，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件
	如果找到，则进行类的加载，并生成对应的Class类对象，如果没有找到，则抛出ClassNOtFoundException



	2.为对象分配内存
		首先计算对象占用空间大小，接着在堆中划分一块内存给新对象
		如果实例成员变量是引用变量，仅分配引用变量即可，即4个字节大小
		说明:选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。


	指针碰撞：意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact（整理）过程的收集器时，使用指针碰撞。
![1641905633963](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641905633963.png)

![1641905766809](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641905766809.png)


	空闲列表：虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容，如果垃圾回收器选择的是CMS算法

![1641906147783](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641906147783.png)

![1641906259763](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1641906259763.png)

	3.处理并发安全问题
		CAS ( compare And Swap ）失败重试、区域加锁:保证指针更新操作的原子性
		TLAB 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆预先分配一小块内存，称为本地线程分配缓冲区，（TLAB , Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定


	4.初始化分配到的空间
		内存分配结束，虚拟机将分配到的内存空间都初始化为零值（不包括对象头）。这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型所对应的零值


	5.设置对象的对象头
		将对象的所属类（即类的元数据信息）对象的HashCode和对象的GC信息，锁信息等数据存储在对象的对象头中


	6.执行init方法进行初始化
		初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址值赋值给引用变量


## 对象的访问定位
	方式一：直接使用指针访问
	方式二：句柄访问：堆需要分配出一块内存来做句柄池，referenec中存储对象的句柄池地址，句柄池中包含对象实例的地址信息
	相对于方式一的优点：reference中存储稳定句柄地址，对象被移动，（GC时移动对象很普遍）时只会改变句柄中实例指针，reference本身不需要被修改

# 执行引擎
	JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息。
	那么，如果想要让一个Java程序运行起来，执行引擎(Execution Engine)的任务就是将字节码指令解释/编译为对应平台上的本地机器指令才可以。简单来说，JVMF的执行引擎充当了将高级语言翻译为机器语言的译者。

## 执行引擎是如何工作的

![1642059718174](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642059718174.png)

	1）执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器。
	2）每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址。
	3）方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。

## 代码编译和执行过程

![1642060049403](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642060049403.png)

## 为什么Java是半编译半解释型的语言

![1642060542229](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642060542229.png)

	解释型：出现一条指令，执行一次指令，有可能同一条指令执行了n多次，但启动速度快，采用热执行
	
	编译型：将代码全都敲出来，最后在翻译，在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码，并部署至托管环境中的过程。 在java中热点代码就会被JIT执行


	AOT编译器(静态提前编译器，Ahead Of Time Compiler)：在程序运行之前，便将字节码转换为机器码的过程。


	.java —》 .class —》.so 缺点：
	破坏了java“一次编译，到处运行”，必须为每个不同硬件、OS编译对应的发行包。
	降低了Java链接过程的动态性，加载的代码在编译期就必须全部已知。
	在HotSpot VM中内嵌有两个JIT编译器，分别为Client Compiler和Server Compiler，但大多娄情况下我们简称为C1编译器和C2编译器。开发人员可以通过如下命令显式指定Java虚拟机在运行时底使用哪一种即时编译器，如下所示:
	
	-client:指定Java虚拟机运行在Client模式下，并使用C1编译器;
	C1编译器会对字节码进行简单和可靠的优化，耗时短。以达到更快的编译速度。
	client启动快，占用内存小，执行效率没有server快，默认情况下不进行动态编译，适用
	桌面应用程序。
	
	-server:指定Java虚拟机运行在Server模式下，并使用C2编译器。
	C2进行耗时较长的优化，以及激进优化。但优化的代码执行效率更高。. server启动慢，占用内存多，执行效率高，适用于服务器端应用


​	
​	由-XX:+RewriteFrequentPairs参数控制。client模式默认关闭，server模式默认开启。
​	
​	C1（client）和C2（server）编译器不同的优化策略：
​	
​	在不同的编译器上有不同的优化策略，C1编译器上主要有方法内联，去虚拟化、冗余消除。
​	方法内联:将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程
​	去虚拟化:对唯一的实现类进行内联
​	冗余消除:在运行期间把一些不会执行的代码折叠掉
​	C2的优化主要是在全局层面，逃逸分析是优化的基础。基于逃逸分析在c2上有如下几种优化:	   标量替换:用标量值代替聚合对象的属性值


	栈上分配:对于未逃逸的对象分配对象在栈而不是堆·同步消除:清除同步操作,通常指synchronized


总结:

	一般来讲，JIT编译出来的机器码性能比解释器高。
	C2编译器启动时长比C1编译器慢，系统稳定执行以后，C2编译器执行速度远远快于C1编译器。

# 垃圾回收
	现代语言的特征就是垃圾回收


## 哪些内存需要回收
## 什么时候需要回收
## 什么时候需要回收
## 如何回收

## 什么是GC
	GC（Garbage clean）
## 为什么要GC
	如果不进行GC，内存迟早被消耗光
## 垃圾回收的主要区域
	Java堆是垃圾回收的重点区域，除了Java外，C#、Python、Ruby等语言都使用了自动垃圾回收的思想

## 如何标记一个死亡对象
	简单来说，当一个对象已经不在被任何的存活对象继续引用时，就可以宣判已经死亡

## 垃圾判别阶段算法
	引用计数算法：对每个对象保存一个整型的引用计数器，属性。用于记录对象被引用的情况
	原理：当任何对象引用了A地址，A的引用计数器就加一
	当引用失效时，引用计数器就减一，当对象的A的引用计数器的值为0，即表示对象A不可能在被使用，可进行回收
	优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性
	缺点：无法解决处理循环引用的问题

![1642246351058](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642246351058.png)

## 什么叫内存泄露
	当垃圾回收器检测不到需要清理的垃圾时，则此垃圾所占用的内存称为内存泄露
	静态集合类：静态变量一直存在于JVM的生命周期

```
public class MemoryLeak i
static List list = new ArrayList();
public void oomTests( ) i
object obj = new objecd(;//局部变量list.add(obj);
}
```
	单例模式（特殊的静态方法）
	内部类持有外部类
	各种连接，如数据库连接，网络连接和IO连接
	变量不合理的作用域

​	

```
public class UsingRandom {
private String msg;
public void receiveMsg(){
// private String msg;
readFromNet();/l从网络中接受数据保存到msg中saveDB();把msg保存到数据库中
//msg = null;
}
}
```



	改变哈希值
	缓存泄露:弱引用
	监听器和回调：客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚。


## 什么叫内存溢出

	垃圾回收赶不上内存占用的速度
	字符串缓存过多
## OOM之前一定会有GC吗
	我们分配一个超大对象，类似于一个超大数组超过堆，就直接OOM了


## 如果想用此算法，怎么解决循环引用	
	手动解除：在合适的时机，解除引用关系
	使用弱引用weakref、它是Python提供的标准库，意在解决循环引用，发现即回收

## 可达性分析算法

![1642246985358](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642246985358.png)

	没有连接根的都会被吸收，优点：实现简单，执行高效，有效的解决循环引用的问题，防止内存泄露

## 哪些可以作为GCROOTS
	常见的异常，类静态变量，局部变量表，虚拟机栈引用的对象、方法区中常量
	由于Root采用栈方式存放变量和指针、所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root，静态变量除外（因为静态变量存放在堆中）
	缺点：必须在一个能保障一致性的快照中进行

## 垃圾清除阶段算法![1642248004826](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642248004826.png)

## 将得到的存活对象复制一份保存到新内存中

![1642248133825](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642248133825.png)

	优点：没有标记和清除过程，实现简单，运行高效
		 复制过去，不会出现“碎片问题”
	缺点：此算法的缺点也是很明显的，就是需要两倍的空间
		 如果系统中的存活对象很多，复制算法不会很理想。因为复制算法需要复制的存活对象数量不会太大，或者说非常低

## 标记-压缩算法

​	![1642248518472](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642248518472.png)

	标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩(Mark-Sweep-compact)算法。

## 指针碰撞（Bump the Pointer)
	如果内存空间以规整和有序的方式分布，即己用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump the Pointer)。

## 优缺点
	优点:此算法消除了“标记-清除”和“复制”两个算法的弊端。
	消除了标记/清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
	消除了复制算法当中，内存减半的高额代价。
	缺点:
	从效率上来说，标记-压缩算法要低于复制算法。
	效率不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。
	对于老年代每次都有大量对象存活的区域来说，极为负重。
	移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
	移动过程中，需要全程暂停用户应用程序。即:STW（Stop The World）

![1642257867916](C:\Users\JunHao\AppData\Roaming\Typora\typora-user-images\1642257867916.png)

分代收集算法，是基于这样一个事实 ：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根捷各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

​	新生代朝生夕死，适合用效率最高的复制算法。老年代需要长期保留，只需要清除碎片即可，适合用标记压缩算法或标记清除算法
​	标记阶段的开销与存活对象的数量成正比
​	Sweep阶段的开销与所管理区域的大小成正比
​	Compact阶段与存活对象的数据成正比

## 增量收集算法
	垃圾每次只收集一小片区域的内存空间，接着切换到应用程序线程，依次反复，直到垃圾收集完成，增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理和复制工作
	缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降

System.gc()和Runtime.getRuntime.gc()会做什么事情?
	获取实例，通过实例获取gc方法（本地方法）

## finalize的执行过程
	当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该象是否可达，若不可达，则进行回收，否则，对象“复活”

## 安全点(Safepoint)
	程序执行时并非在所有地方都能停顿下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点（Safepoint）”。
Safe Point的选择很重要，如果太少可能导致Gc等待的时间太长，如果太频繁可能导致行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如:选择一些执行时间较长的指令作为Safe Point，如方法用、循环跳转和异常跳转等。

## 安全区域(Safe Region)
	Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC 的Safepoint。但是，程序“不执行”的时候呢?例如线程处于Sleep 状态或Blocked状态，这时候线程无法响应JVM 的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region）来解决。

## 垃圾回收器有哪些
	G1 GC：区域化分代式
	CMS：低延迟
	Parallel GC：吞吐量优先
	ParNew GC：并行回收
	Serial GC：串行回收

# JVM性能调优（实践）

# JVM性能监控（实践）




