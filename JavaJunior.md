# 计算机壳层（终极Shell——ZSH）
	Shell是Linux/Unix的一个外壳。它负责外界与Linux内核的交互，接收用户或其他应用程序的命令，然后把这些命令转化成内核能理解的语言，传给内核，内核是真正干活的，干完之后再把结果返回用户或应用程序。
## Zsh 是什么
	Zsh 属于 Shell 的一种，和 Bash 一样，但比 Bash 更好用，Zsh 完全兼容 Bash，拥有极其丰富的插件，其强大的自动补全参数、文件名以及自定义功能，可以大大提高我们使用 Linux 的效率。
## 详细介绍
https://zhuanlan.zhihu.com/p/19556676
## 查看系统是否安装ZSH
	cat /etc/shells

## 显示如下：
	/bin/bash
	/bin/csh
	/bin/ksh
	/bin/sh
	/bin/tcsh
	/bin/zsh

## 安装zsh
	Redhat Linux，执行：sudo yum install zsh
	Ubuntu Linux，执行：sudo apt-get install zsh
	安装完成后设置当前用户使用 zsh：chsh -s /bin/zsh

## 安装zsh主题
	第一次安装需要下载开发者工具，以便使用git下载，新版mac上删除了Xcode工具
	https://developer.apple.com/download/all/?q=Xcode%20Command%20Line%20Tools
	接着使用git下载zsh主题
	git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
	cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
	重新打开终端

## Mac系统的环境变量，加载顺序
	/etc/profile
	/etc/paths
	~/.bash_profile
	~/.zshrc

## 通用命令
	管道（PIPING）| 一种管道，其左方是一个命令的 STNOUT，将作为管道右方的另一个命令的 STDIN
	例如：echo ‘test text’ | wc -l
	注：wc命令用于计算字数。利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为"-"，则wc指令会从标准输入设备读取数据。


	>大于号，作用是取一个命令 STDOUT 位于左方，并将其写入/覆写（overwrite）入右方的一个新文件
	例如：ls > tmp.txt
	>>两个大于号，作用是取一个命令 STDOUT 位于左方，并将其追加到右方的一个新的或现有文件中。
	例如：date >> tmp.txt


	通配符（WILDCARDS）
	这类似于 SQL 中的 % 符号，例如，使用「WHERE first_name LIKE John% 」搜索所有以 John 起始的名字
	在 bash 中，相应的命令是「John*」。如果想列出一个文件夹中所有以「.json」结尾的文件，可以输入：「ls *.json」


退出命令：

Bash

	CTRL+C
	q
	exit


Python

	quit()
	CTRL+d

Nano

	CTRL+X



## 常用命令
	vim or nano：命令行编辑器
	touch {file}：创建一个新的空文件
	cp -R {original_name} {new_name}：复制一个文件或目录（包含内部所有文件）
	mv {original_name} {new_name}：移动或重命名文件
	rm -rf {file/folder}：永久删除文件或文件夹（小心使用）
	pwb：打印当前工作目录
	cat or less or tail or head -n10 {file}：文件的标准输出内容
	mkdir {directory}：创建一个空的目录
	grep -r {string} . ：在当前目录或子目录的文件中搜索一个字符串
	<mount/cat> column -t <delimited_file>：在 columnar格式中展示逗号分隔文件
	ssh {username}@{hostname}：连接到远程机器中
	top：任务管理器
	pip install --user {pip_package}：
		Python 安装包管理器，安装包到~/.local/bin 目录下

## 替换命令
	alias cls='clear'
	alias la='ls -a'
	alias dir='ls -l'
	alias type='cat'
	alias javac="javac -J-Dfile.encoding=utf8"
	alias grep="grep --color=auto"
	alias -s html=mate   #在输入后缀为 html 的文件名，会在 TextMate 中打开
	alias -s rb=mate     # 在命令行直接输入 ruby 文件，会在 TextMate 中打开
	alias -s py=vi       # 在命令行直接输入 python 文件，会用 vim 中打开
	alias -s js=vi
	alias -s c=vi
	alias -s java=vi
	alias -s txt=vi
	alias -s gz='tar -xzvf'
	alias -s tgz='tar -xzvf'
	alias -s zip='unzip'
	alias -s bz2='tar -xjvf'

# 简述编程语言
	编程语言(programming language),是用来定义计算机程序的形式语言.
	它是一种被标准化的交流技巧,用来向计算机发出指令,计算机收到指令并执行相应的动作
##	硬件
### CPU频率
简单说是CPU运算时的工作频率(1秒内发生的同步脉冲数.单位是Hz)
	1khz=1024hz
	1mhz=1024khz
	1ghz=1024mhz

###	存储单位
计算机中最基本的储存单位是字节(byte).

	一个0(关)或者一个1(开)储存为一个bit,每个字节由8个比特(bit)组成

### 屏幕像素
	长的像素点*宽的像素点
	像素密度(ppi)=V[[长度像素数]^2+[宽度像素数]^2]/屏幕尺寸

##	进化史
编程产物

	算法+数据结构=程序(例如：数组,线性结构,树形结构,二叉树)
	Algorithms+Data Structures=Programs

初代语言

	机器语言：使用01关开(也用于表示boolean值,false,true)

二代语言

	汇编语言：使用助记语言(例如add)

三代语言

	高级语言：C(面向过程) Java  Python scala C#(面向对象) 

##	编程语言分类

Java

	Java作为构建现代企业Web应用后端的最常用编程语言之一,是一门必须掌握的编程语言.
	网站开发人员凭借Java和基于Java的框架可以为各种用户创建可扩展性的Web应用.
	Java也是用来开发Android系统原生应用的主要编程语言之一.

JavaScript

	现代网站离不开JavaScript.
	如果你想为你的网站创造互动,或者用时下流行的JavaScript框架搭建一个用户界面,那么JavaScript是最佳选择.

C#

	C#是Windows开发环境下的主要语言.
	无论你是用微软云计算平台Windows Azure和.NET框架来创建现代网页应用,
	还是开发Windows设备上的应用,又或者是为你的企业开发功能强大的桌面应用,
	C#能够迅速地帮助你驾驭微软提供的所有功能.
	可以开发游戏吗？当然,非常流行的Unity游戏开发引擎就把C#作为了自己的主要开发语言

Python

    Python几乎可以做任何编程工作.
    Web应用,用户交互界面,数据分析,统计等等.
    不管是什么问题,你总能在Python中找到需要的框架.
    近期,Python又成为了数据科学家用来筛选大型数据集的重要工具.

SQL

    数据很重要,它无处不在,它复杂多变.
    这时候,你需要SQL来帮助你以快速,可重复且可靠的方式准确找到信息.
    有了SQL,你可以轻轻松松地从庞大复杂的数据库中查询,提取有意义的数据.

R语言

    R语言推动了大数据革命,也是数据分析研究者在2015年不可不知的编程语言之一.
    从科学和商业到娱乐和社会媒体,每一个需要统计分析的领域都少不了R语言.

Scala

    Scala编程语言抓住了很多开发者的眼球.
    如果你粗略浏览Scala的网站,你会觉得Scala是一种纯粹的面向对象编程语言,
    而又无缝地结合了命令式编程和函数式编程风格.

C

	广泛应用于底层开发，以简易的方式编译、处理低级存储器，不需要任何运行环境支持便能运行的高效率程序设计语言

C++

	保持了对C语言的兼容性，允许指针的存在，允许程序员手动高效的管理内存，凭借先进的数值计算库、泛型编程等优势在游戏领域应用颇多
	可以开发游戏吗？当然,非常流行的Unreal游戏开发引擎就把C++作为了自己的主要开发语言

Go

	Go语言更适合开发大型软件，并且开发周期较长，支持云计算的网络服务，也就是服务器端软件，Go语言能够让程序员快速开发，并且在软件不断的增长过程中，它能让程序员更容易地进行维护和修改。它融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性。

# 主学Java的特点
面向对象
	面向对象的两个基本概念：类、对象(类派生出来的)

健壮性
	提供了一个相对安全的内存管理(垃圾回收机制)和访问机制
	去除了c语言的指针、自动的回收机制 ——》仍然会出现内存溢出、内存泄露

跨平台性
	安装一个JVM(Java Virtual Machine)即可实现write once,run anywhere

## 面向对象的特性
    封装、多态、继承、抽象

## 特性和特点的区别
    特点一般指外在的，特性指的是内在的

## JDK、JRE、JVM

	JDK包括JRE，JRE包括JVM，所以只需要在不同系统中
	选择不同版本的JDK，就可以实现运行。


	JDK可以支持Java程序的开发,包括编译器(javac.exe)开发工具(javadoc.exe、jar.exe、keytool.exe、jconsole.exe)和更多的类库(如tools.jar)等.
	JRE可以支撑Java程序的运行,包括JVM虚拟机(java.exe等)和基本的类库(rt.jar).   

# 关键字
被Java语言赋予了特殊含义，用做专门用途的字符串

## 特点
关键字中所有的字母均为小写

## Main
里面的变量,都是局部变量.

## New
实例化的对象都在堆空间

## 标识符
Java对各种变量、方法和类等要素命名时使用的单词称为标识符
	
	助记：是自己可以起名字的都是标识符
	命名规则：
	由26个英文字母大小写，0-9，_或$组成
		①数字不可以开头
		②不可以使用关键字和保留字
		③标识符不能包含空格
	保留字：
		goto、const

# 命名规范
类名\接口1024

	XxxxYyyy


## 方法名

	变量名\参数名\成员变量\局部变量(函数名)(实例化对象名)
	xxxYyyZzz
	int userId = a++
	void myClass 


## 常量名 

	所有字母都大写.多单词时每个单词用下划线连接
	int NAME_ID =3

## 抽象类
	命名使用 Abstract 或 Base 开头

## 异常类
	命名使用 Exception 结尾

## 测试类
	命名以它要测试的类的名称开始,以 Test 结尾

## 布尔类型
	变量不要用is开头

## 自定义类型
	在自定义类里面写上简单易懂的单词

## 标识符
	我们对各种 接口\变量\方法\类 等要素命名时使用的字符序列(单词)称为标识符

# 基本数据类型变量
变量都定义在作用域内(“{}”),在作用域内("{}"),它是有效的
## 整型

	.byte (1字节) .short(2字节) int(4字节) long(8字节)
	1byte=8bit  字节(byte)范围：-128 ~ 127    2^8=256      

## 浮点型
	float(4字节)/double(8字节)
	float精确到尾数后七位,声明浮点型变量,必须以f结尾

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
float f1 = 1324.2333f
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


## 字符型变量
	char(2字节) 
	定义char型变量,通常使用一对' ' , 内部只能写一个字符
	在使用加法运算时,会自动转化为int类型
	char a = 'c'

## 长整型变量
	long(4字节)
	声明long型变量,必须以L结尾
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
long l2 = 7882333882L
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## 布尔型变量
Java虚拟机直接支持 boolean类型的数组
虚拟机中没有供 boolean值专用的字节码指令,Java语言表达式所操作的boolean值,在编译之后都使用虚拟机中的int数据类型来代替。
因为在虚拟机规范中说了，boolean值在编译之后都使用Java虚拟机中的int数据类型来代替，而int是4个字节，那么boolean值就是4个字节。
boolean类型数组的访问与修改共用byte类型数组的baload和 bastore指令，因为两者共用，只有两者字节一样才能通用呀，所以byte数组中一个byte是1个字节，那么boolean数组中boolean是1个字节。

	Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 还要看虚拟机实现是否按照规范来，所以1个字节、4个字节都是有可能的

# 注释

用于有关变量,方法,类或其他任何语句的解释,并且不被编译器和解释器执行的语句.

##  注释的作用
更加方便的记录你的程序信息,更容易理解代码属性及方法.

## 如何使用
    java有三种注释：
    .文档注释 
    /**
    @auther fujunhao
    @version v1.0
    这是我的第一个java程序!非常的开心
    */

只有 /**    */ 才可以被javadoc解析
            .单行注释   
            //This is single line comment
            .多行注释  
            /* This is multi line comment */
##  斜杠与反斜杠
###  斜杠
    / 表示地址路径的下一级目录 
### 反斜杠
	\ 表示转义字符
	如果要输出反斜杠“\”也需要用转义字符：“\\” ,例如:\\n:能够输出\n.
## 转移符号
	\n:表示换行
	\":表示一个英文半角的双引号
	\t:表示一个tab键的空格
	\b:表示一个退格键,放到字符串的两边没有效果
	\r\n:windows操作系统不认识\n,只认识\r\n
	\\:表示一个\(适合输出到Windows系统)
	@符号
	1,取消\在字符串中的转义作用
	2,将字符串按照原格式输出

# 类型转换
	byte,short,char -->int -->long-->float-->double
	当byte\char\short进行混合运算时,会自动提升为int

## 强制转换

``` java
float l1 = 12.9;
int a = (int)l1;
```

将String类型转化为int类型

``` java
int num1 = Interger.parseInt(str1);
System.out.println(num1);
```

指定转换到小数点后几位
```java
system.out.println("{0:0.00}",d);
//表示留变量d的小数点后2位
```

# 运算符
## 取模(取余) % 
% 长得像一条鱼,所以是取余.结果的符号与被模数的符号相同,与模数无关.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
7%5=2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## 除号(取整) /
/ 长得像把刀,所以是斩断小数,只留商.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
7/5=1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

## 加号
    ++a :先自增1,在将加数赋给被加数.
    a++：先将加数值赋给被加数,在自加一

## 比较
    比较运算符:== !=  >= <=
    赋值运算符:=  
    扩展赋值运算符：+=,-=,*=,/=,%=

## 逻辑
区分&与&& 和 |与||
### 且
	当符号左边是false时,&会继续执行符号右边的计算,&&不再执行右边的计算
### 或
	当符号左边是false时,|会继续执行符号右边的计算,||还会再执行右边的计算

## 位运算符
	<<:在一定范围内,每向左移一位,相当于 * 2
	>>:在一定范围内,每向右移一位,相当于 / 2  


## 三元运算符
(条件表达式)?表达式1:表达式2

	条件表达式的结果为boolean类型
	如果表达式为true,则表达式为1
	如果表达式为false,则表达式为2 

# 原码
计算机底层都以补码的方式来存储数据

## 正数
	正数的原码、反码、补码都相同

## 负数
	-14的原码：
		10001110
		反码：
		11110001
		补码：
		11110010

## 补码的用处
	计算机中表示负数，如果用最高位表示符号这种“原码”方式，虽然有利于人的阅读，但不利于其本身的计算。所以系统内部就把负数统一用“其对应正数的补码”来表示，而正数自己不用改变。

# 判断语句
## 循环结构
for与while的区别

    For是在已知终止条件的情况下进行循环
    while是在未知终止条件的情况下进行循环
while与do while的区别

	while 是先判断,后执行
	do while是先执行,后判断

## 循环条件
### break	
使流程跳出switch语句体

	也可以用break语句在循环结构终止本层循环体,从而提前结束本层循环    
	只能在循环体和switch语句体内使用break

### continue
跳过本次循环体中本次尚未执行的语句,搭配Label使用，理解为仅结束本次循环.

	continue语句并没有使整个循环终止
	continue label:结束label后面的当次循环

# 数组
多个类型相同的元素按照顺序排列，对数组进行命名，通过角标的方式对这些数据来进行统一管理

## 特点
	有序排列，引用类型变量，数组的元素既可以是基本数据类型，又可以是引用数据类型
	因为数组在内存中是一块连续的空间，所以长度一旦确定，不能更改

## 一维数组
```java
int num; //声明
num = 10; //初始化
int id = 1001; //声明+初始化
```

## 实例化指定位置的元素
### 元素未知
```java
//可以进行动态初始化变量
String [] args = new String[5];
```

### 元素已知
```java
//可以进行静态初始化变量
int [] args1 = new int[]{1001,1002,1003,1004,1005};
args[0] = "马云";//实例化数组的第一位元素为String类型
```
### 获取数组的长度
```java
System.out.println(args.length);//依靠属性length
```

### 数组元素的初始化值
	boolean : 0代表false
	char : ascii码值 0或\u0000,而非字符'0'
	String : null	

## 二维数组
数组的元素又是一串数组
```java
//静态初始化
int[][] arr1 = new int[][] {{11,12,13},{14,15,16}};
//动态初始化
String [][]arr2 = new  String[3][5];
```
### 指定位置的元素
```java
System.out.println(arr4[0][0]);
```

### 查询数组长度
```java
System.out.println(arr4.length);
```

### 遍历数组
```java
//arr[i],它代表着外层的第几个数组
for (int i = 0; i < arr.length; i++) {
   for (int j = 0; j < arr[i].length; j++) {
    System.out.print("["+arr[i][j]+"]"+",");
   }
   System.out.println();
  }
```
### 二维数组元素的默认初始化值
在指定外层数组,但没指定内层数组的情况下 或 引用数据类型默认值 显示为null
```java
System.out.println(arr4);
//arr4数组的地址值
System.out.println(arr4[1]);
//arr4[1]数组的地址值
```
在指定内层和外层数组的情况下显示为数组的元素
```java
System.out.println(arr4[1][0]);//数据
```
### 内存解析

![image-20220218204703445](E:\Typora\JavaJunior\image-20220218204703445.png)

![image-20220218204724391](E:\Typora\JavaJunior\image-20220218204724391.png)
### 数组的复制

```java
//arr2 = arr1//并不是真正的复制,只是将arr2的地址值赋给了arr1,相当于arr2是arr1的快捷方式
int arr2[i] = new int [arr1.length]
for(i=0;i<arr2.length;i++)
```

### 数组的反转
```java
//for循环遍历并不是真正的将数组里面的值进行反转
for(min=0,max=arr.length-1;min<=max;max--,min++){
                int temp =arr[min];
                arr[min] =arr[max];
                arr[max] =temp;
}
```

### 数组元素的查找
#### 线性查找
```java
String dest = "BB";
dest="CC";
boolean isFlag = true;
for(int i=0;i<arr.length;i++){
	if(dest.equals(arr[i])){
	System.out.println("找到了指定的元素，位置为："+i);
	isFlage=false;
	break;
	}
}
if(isFlage){
	System.out.println("很遗憾，没有找到的啦~")
}
```
#### 二分法查找（折半查找）
所要寻找的数组必须有序
```java
int[] arr2 = new int[]{-98,-34,2,34,54,66,48,78,105,210};

int dest1 = -34;
dest1 = 35;
int head=0;
int end =arr2.length-1;
boolean isFlage = true;
while(head <= end){
	int middle = (head+end)/2
	if(dest1 == arr2[middle]){
		System.out.println("找到了指定的元素，位置为："+middle);
		isFlag = false;
		break;
	}else if(arr2[middle]>dest1){
		end=middle-1;
	}else{
		head = middle+1;
	}

}
```
# 面向对象
	强调了具备功能的对象,以类/对象为最小单位,考虑谁来做
	类与对象的内存关系:类是不占内存的,而对象是占内存的
## 示例代码
```java
//人的调用(主体)
人{
	打开(冰箱){
	冰箱，开开();
		}
	抬起(大象){
	大象，进入(冰箱);
	}
	关闭(冰箱){
	冰箱,闭合();
		}
    }
    
//定义的一个功能
冰箱{
	开开(){ }
	闭合(){ }
     }

//定义的另一个功能
大象{
	开开(){ }
     }
```

## 三大并行主线任务
Java类及类的成员、面向对象的三个特征、其他关键字

	1.Java类及类的成员:属性、方法、构造器;代码块、内部类
	2.面向对象的三个特征:封装性、继承性、多态性
	3.关键字:this、super、static、final、abstract、interface、import

## 学习方法
大处着眼,小处着手

	目前我所处的阶段：我知道我不知道
	面向对象的编程思想：编程有编程的原则,编程的原则就叫做编程的思想.(形而上学)

## 思路与步骤
	选择问题所针对的现实世界中的实例.
	寻找解决问题相关的属性和方法,这些属性和方法就形成了概念世界的类.
	将类实例化为概念世界中的类.
## 两个要素(类和对象)
	类：对一例事物的描述,是抽象的,概念的定义.
	对象：实实在在的对一例事物描述.(对象的功能完全取决于类)
		属性=field=域、字段
		方法=成员变量=函数.		     
		生活中描述事物无非就是描述事物的属性和行为

## 如何理解"万事万物皆对象"
在Java语言内,我们都将功能、结构等封装到类中,通过类的实例化,来调用具体的功能结构

		>Scanner,String等
		>文件:File
		>网络资源:URL   
		>涉及到Java语言外与前端html、后端的数据库交互时、前后端的结构在Java层面交互时,都体现为（类、对象）

# 方法结构

## 方法在不同位置的差异
属性(成员变量) VS 局部变量(声明在方法内)
### 相同点

	只要是变量,格式都是相同的.
	数据类型 变量名=变量值.
	先声明,后使用.
	变量都有其对应的作用域.

### 不同点
#### 在类中声明的位置不同
	属性:直接定义在自定义类的一对{}内
	局部变量:声明在方法内,方法形参(局部变量),代码块内,构造器形式参数构造器内部的变量.

#### 权限修饰符的不同
	属性：可以在声明属性时,指明其权限,使用权限修饰符
	局部变量：不可以使用权限修饰符

#### 默认初始化值的情况
	属性：类的属性,根据其类型都有其默认初始化值.
	    字符型(char),0(或'\u0000')
	    布尔型(boolean),false
	    引用数据类型(类,接口,数组),null
	局部变量：没有默认初始化值
		意味着,我们在调用局部变量之前,一定要有显示赋值
		特别的,形式参数调用时,我们赋值即可.

#### 在内存中加载的位置
	属性：加载到堆空间中（非static） .
	局部变量：加载到栈空间中

#### 类中方法的声明和使用
	方法(行为):描述类应具有的功能(每个方法中一定有下列几个部分)
方法的声明:
```java
权限的修饰符 返回值类型 方法名(形参列表){
			方法体 }
```

形式参数可以有多个,格式:
```java
数据类型1 形参1,数据类型2 形参2.
```
#### 方法的使用
实例化对象

	Object obj = new Object();
调用对象

	实例化对象.调用对象();
	特殊关键字:static\final\abstract

# 内存结构
我们使用JVM中(类的加载器和解释器)对生成的字节码文件进行解释运行.意味着,需要将（字节码文件对应的类)记载到内存中
## 内存结构图

![image-20220223091650914](E:\Typora\JavaJunior\image-20220223091650914.png)
## 名词解释
	编译完源程序后,会生成一个或多个字节码文件.
	虚拟机栈,即为平时提到的栈结构.我们将局部变量储存在栈结构中.
	堆,我们new出来的结构(比如数组,对象), 对象的属性(非static)加载到堆空间中.
	方法区:类的加载信息,常量池,静态域
## 基本数据VS引用数据类型
	基本数据类型:赋值的是变量所保存的数据值.
	引用数据类型:赋值的是变量所保存的数据的地址值.

# 匿名对象
创建对象的时候，没有显式的赋一个变量名，意味着匿名对象只能调用一次

## 示例代码

```java
//普通实例化对象
Phone p = new Phone();
p.callNumber();

// 匿名对象的使用一
new Phone().callNumber();
new Phone().playGame();

// 匿名对象的属性
new Phone().price = 1999;
new Phone().showPrice();// 0.0

// 匿名对象的使用二
PhoneMall mall = new PhoneMall();
mall.show(new Phone());
Tips:前面加mall.show()对象,代表的是从PhoneMall类里面调取的一部分Phone的功能
```

# 方法重载
构成方法重载的两同一不同

	同一个类,相同方法名
	参数列表不同,参数个数不同,参数类型不同

## 判断是否重载
	与方法的权限修饰符,返回值类型,形参变量名,方法体都没有关系！ 

## 在通过对象调用方法时,确定某一个指定的方法
	方法名--->参数列表

## 可变个数形参
	可变个数形参的格式:数据类型...变量名 

```java
public static void main(String[]args){
	MethodArgsTest test = new MethodArgsTest();
	test.show("Hello","darling");
	}
public void show(String...strs) {// 不能和String[] args共存
	System.out.println("show(String...strs)");
	}
```




# 方法重写
子类继承父类后,可以对父类中同名同参数的方法,进行覆盖操作
## 应用
	当创建子类对象后,通过子类对象调用子父类中的同名同参数的方法时,执行的是子类重写父类的方法

```java
方法的声明:权限修饰符 返回值类型 方法名(形参列表){
		//方法体
}
```
## 规定
	子类中的叫重写的方法,父类中的叫被重写的方法
	子类重写方法的方法名和形参列表,与父类被重写的方法的方法名和形参列表相同
	子类重写方法的权限修饰符不小于父类被重写的方法的权限修饰符
	子类不能重写父类中声明为private权限的方法
	子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型
	子类和父类中的同名同参数的方法要么都声明为非static的,要么都声明为static的


	父类中被重写的方法的返回值类型是void,则子类重写的方法的返回值类型只能是void 
	父类中被重写的方法的返回值类型是A类型,则子类重写的方法的返回值类型可以是A类或A类的子类
	父类中被重写的方法的返回值类型是基本数据类型,则子类重写的方法的返回值类型必须是相同的基本数据类型

# 封装性
面向对象的特征之一：封装性

	在实际问题中,我们往往需要给属性赋值加入额外的限制条件
	这个条件就不能在属性声明时体现,我们只能通过方法进行限制条件的添加
	我们需要避免用户在使用"对象.属性"的方式对属性进行赋值.则需要将属性声明为私有的
## 代码示例
```java
private int number;
public void setNumber(int number) {
    if (number>10){
        this.number = number;
    }else {
        System.out.println("数据非法");
    }
}
public int getNumber(){
    return number;//这个return的功能才是将函数xxx传递到main方法区中
    }
}   
```

## 为什么会有封装性
	封装性就是保证类内部的的定义不被外部可见
	所有属性都必须使用private封装,封装后的属性如果要被外部所访问,要定义相应的setter和getter方法.

## 权限修饰符
JAVA规定的4种权限(从大到小):private>缺省>protected>public

| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   | Yes    |          |              |            |
| (缺省)    | Yes    | Yes      |              |            |
| protected | Yes    | Yes      | Yes          |            |
| public    | Yes    | Yes      | Yes          | Yes        |

权限修饰符可以用来修饰属性、方法、构造器、内部类
	修饰类的时候,只能缺省,public
	内部类可以使用private

# 继承性
面向对象的特征之二：继承性

### 优点
	减少了代码的冗余,提高了代码的复用性
	便于功能的扩展
	为之后多态性的使用,提供了前提
### 应用
```java
class A extends B{}
```
	A:子类、派生类、subclass
	B:父类、超类、基类、superclass

### 体现
	一旦子类A继承父类B以后,子类A就获取了父类B中声明的结构:属性、方法.
	父类中声明为private的属性和方法,子类继承父类之后,仍然认为获取了父类中私有的结构,
	子类继承父类以后,还可以声明自己特有的属性或方法:实现功能的扩展.
	子类和父类的关系,不同于子集和集合的关系,因为子类可以衍生出更多的方法和属性.

### 规定
	一个类中可以被多个子类继承,子父类是相对的概念
	Java中类的单继承性:一个类只能有一个父类

### Object类
	如果没有显式的声明一个类的父类的话则此类继承于java.lang.object类
	意味着,所有的java类具有java.lang.Object类声明的功能
	所有的java类都直接或间接的继承于java.lang.Object类

# 多态性
面向对象的特征之三：多态性，一个事物多种表现。

## 为什么用多态
	假如没有多态,只使用重载的话,就会每调用一次形参,就需要重载一次方法,非常麻烦.

## 示例代码
```java
Person p = new Man();
```
```java
public class AnimalTest {

	public static void main(String[] args) {
		
		AnimalTest test = new AnimalTest();
		//使用多态
		Animal test2 =new Cat();
		test2.shout();
		//进一步简化
		test.func(new Cat());
	}
class Animal {
	public void eat() {
		System.out.println("动物,进食");
	}

	public void shout() {
		System.out.println("动物,叫");
	}
}

class Cat extends Animal {
	public void eat() {
		System.out.println("猫吃鱼");
	}

	public void shout() {
		System.out.println("喵!喵!喵!");
	}
}
```
## 定义
	将子类的对象赋给父类的引用.
	新建对象p时,声明的是Person,调用的是继承Person类的子类.
	当调用子父类同名同参数的方法时,实际执行的的是子类重写父类的方法.

## 规则
	要有方法的重写 
	要有类的继承关系 
	对象的多态性,只适用于方法,不适用于属性 

## JVM角度
	在编译期,只能调用父类中声明的方法,但在运行期,我们实际执行的是子类重写父类的方法
	子类重写了父类的方法,在多态情况下,将此时 父类的方法(实际上不调用父类的方法) 称为虚拟方法,父类根据赋给它的不同子类对象,动态调用(实际调用子类的方法)属于子类的该方法.这样的方法调用，重写在编译期是无法确定的,只有在运行期才能够调用,所以多态编译时属于运行时行为.

## instanceof
判断对象a是否是类A的实例.如果是返回true,如果不是返回false.

	a instanceof A

## 如何证明多态编译时，是运行时行为
	因为总有些杠精说编译的时候,就能看到了呀,那不是new 的对象吗?那么我们该如何证明多态编译是运行时行为呢?
	代码见com.tencent.day11中InterviewTest

# static
使用static修饰的称为静态变量，能够被任何方法调用，并在执行该类时自动调用静态方法

## 规则
	某些特定的数据在内存中只有一份
	可以用来修饰 属性、方法、代码块、内部类、但不能修饰构造器
	静态方法中,只能调用静态的方法或属性
	非静态方法中,既可以调用非静态的方法或属性,也可以调用静态的方法或属性
	在静态的方法内,不能够使用this关键字,super关键字
	属性是可以被多个对象所共享,不会随着对象的不同而不同,则可以声明为static属性

## 静态属性
创建了类的多个对象,多个对象共享一个静态变量

	静态变量的加载要早于对象的创建.
	当通过某一个对象修改静态变量时,会导致其他对象调用此静态变量,是修改过了的.

### 静态变量的应用
	由于类只加载一次,则静态变量在内存中也会存在一份
	静态变量随着类的加载而加载.可以通过"类.静态变量"的方式进行调用,不需要在使用对象.属性,因此叫做类变量

## 非静态属性（实例变量）
创建了类的多个对象,每个对象都独立的拥有一套非静态属性.

	当修改其中一个对象中的非静态属性时,不会导致其他对象中同样的属性值的修改.

## 静态与非静态属性对比图
| 能否自行调用 | 静态变量 | 实例变量 |
| ------------ | -------- | -------- |
| 类           | Yes      | No       |
| 对象         | Yes      | Yes      |


# 一叶知秋
## public static void main(String [] args){//方法体}

	权限修饰符：private 缺省 protected public ---> 封装性
	修饰符：static \ final \ abstract \ native  可以用来修饰方法
	返回值类型：无返回值 \ 有返回值
	方法名：需要满足标识符命名的规则、规范：“见名知意”
	形参列表：重载、重写；参数的值传递 ---> 多态性、继承性
	方法体：体现方法的功能

# 构造器
如果没有显式的定义类的构造器的话,则系统默认提供一个空参的构造器.
一个类中定义的多个构造器,可以进行重载.
一旦我们显式的定义了类的构造器之后,系统就不再提供默认的空参构造器. 

## 构造器作用
创建对象、给对象进行初始化、Constractor(构造器 或 构造方法)
	Person p = new Person()//创建类的对象:new Person()

	一个显式构造器的格式:权限修饰符 类名(形参列表){
		syso     
	}

## 构造器和方法的区别
有无返回值(void)的类型

# 赋值顺序
## 执行程序顺序：①-②/⑤-③-④

	1.默认初始化值
	2.显式初始化值 5.在代码块中赋值
	3.构造器中赋值
	4.通过"对象.方法"或"对象.属性"的方法进行赋值

# This
## 分清属性和形参

	在类的方法中,如果方法的形参和类的属性同名时,我们必须显式的使用“this.属性”方法
	在构造器中,如果方法的形参和类的属性同名时,我们必须显式的使用“this.属性”方法

## 调用构造器中的属性或方法

	1.我们在类的构造器中,可以显式的使用"this(形参)"方式,调用本类中的.其他.构造器
	2.构造器中不能通过"this(形参列表)"方式调用自己,只能调用其他的构造器.
	3.如果一个类中有n个构造器,则最多有n-1个构造器中使用了"this(形参列表)"
	4.规定："this(形参列表)”必须声明在当前构造器的首行
	5.构造器内部,最多只能声明一个"this(形式参数)",用来调用其他的构造器


	this(); 调用同一个类的空参
	this(a, b);调用一个指定参数为int a , String b类型的参数

# Super
在一个类中既能使用父类被重写的方法,又能使用父类原来的方法.

## 应用
	当子类和父类中定义了同名的属性时,我们要想在子类中调用父类中声明的属性,则必须显式的使用"super.属性"的方式,表明调用的是父类中声明的属性
	父类中声明的属性或者方法.我们习惯省略"super".

## Super调用构造器
	在子类的构造器中显式的使用"super(形参列表)"的方式,调用父类中声明的指定的构造器
### 规则
	"super(形参列表)"的使用,必须声明在子类构造器的首行!
	在类的构造器中,针对于"this(形参列表)"或"super(形参列表)"只能有一个在首行
### 默认值
	super(); 表示为super默认为空值
	在构造器的首行,没有显式的声明"this(形参列表)"或"super(形参列表)"
	注意构造器默认super,会调用父类构造器中的值
	在类的多个构造器中,至少有一个类的构造器使用了"super(形参列表)",调用父类中的构造器
	super.xx可以用来继承原来的父类,还能够满足重写方法的要求


# 判断
## ==
### 定义
	比较两个变量保存的数值是否相等:不一定类型要相同,因为有数值提升这一说法
	如果比较的是引用数据类型变量:比较两个对象的地址值是否相同
### 规则
	只能使用基本数据类型变量和引用数据类型变量
	使用 == 符号时,必须保证符号左右两边的变量类型一致.

## equals()
equals( )和 == 的作用相同:比较地址值是否相同.即两个引用是否指向同一个对象实体
### 应用
	String、Date、File、包装类等都重写了Object类中的equals()方法.重写以后,比较的不是两个引用的地址是否相同,而是比较两个对象的"实体内容"是否相同.
	我们自定义的类如果使用equals()的话,也通常是比较两个对象的"实体内容"是否相同.那么,我们就需要对Object类中的equals()进行重写.
### 示例代码
```java
@Override
public boolean equals(Object obj) {
	if (obj instanceof Person) {
		Person person = (Person) obj;
		return name.equalsIgnoreCase(person.getName().trim());
		}
		return false;
}
```
### 规则
	只能适用于引用数据类型
### 为什么会创造equals( )
	equals方法弥补了 == 不能够比较实体内容的缺陷

# JUnit单元测试

## 应用
	选中当前工程一右键选择: build path — add libraries — JUnit 4
	写完代码以后,左键双击单元测试方法名,右键: run as — JUnit Test
## 规则
	此类是public的
	此类提供公共的无参的构造器
	此类必须声明为单元测试方法 @Test
	此时的单元测试方法:方法的权限是public,没有返回值,没有形参

# 包装类
## 基本数据类型—>包装类
	自动装箱
## 包装类—>基本数据类型
	自动拆箱

## String类型—>基本数据类型
	parseXxx()
## 基本数据类型—>String类型
	valueOf()

## Integer
	Integer内部定义了IntegerCache结构,IntegerCache中定义了Integer[],保存了从-128~127范围的整数.如果我们使用了自动装箱的方式,给Integer赋值的范围在-128~127范围内,可以直接使用数组中的元素,不用再去new了
### IntegerCache的意义
提高效率

# 设计模式
设计模式是在大量的实践中总结和理论化之后优选的代码结构,编程风格,以及解决问题的思考方式.

## 创建型模式
	共5种:工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
### 单例模式
	采取一定的方法保证在整个的软件系统中,对某个类只能存在一个对象实例,并且该类只提供一个取得其对象实例的方法.
#### 规则
	如果让类在一个虚拟机中只能产生一个对象,首先必须将类的构造器的访问权限设置为private。这样,就不能用new操作符在类的外部产生类的对象了。
	因为在类的外部开始还无法得到类的对象,只能调用该类的某个静态方法以返回类内部创建的对象,静态方法只能访问类中的静态成员变量,所以,指向类内部产生的该类对象的变量也必须定义成静态的.
## 结构型模式
	共7种:适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式.
## 行为型模式
	共11种:策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
### 模板方法模式
	当功能内部一部分实现是确定的,一部分实现是不确定的,这时可以把不确定的部分暴露出去,让子类实现.

# 代码块
用来初始化类和对象
## 规则
代码块如果修饰的话, 只能使用static

## 静态代码块
	内部可以有输出语句
	随着类的加载而执行,而且只执行一次
	作用:初始化类的信息

## 非静态代码块
	内部可以有输出语句
	随着对象的创建而执行
	每创建一个对象,就执行一次非静态代码块
	作用: 可以在创建对象时,对对象的属性进行初始化